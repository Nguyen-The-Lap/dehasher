<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hash Cracker Pro</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #0f0f1e;
            --bg-secondary: #1a1a2e;
            --bg-tertiary: #16213e;
            --accent-primary: #00f5ff;
            --accent-secondary: #ff00ff;
            --accent-gradient: linear-gradient(135deg, #00f5ff, #7b2ff7, #ff00ff);
            --text-primary: #ffffff;
            --text-secondary: #a0a0b8;
            --text-muted: #6b6b7e;
            --success: #00ff88;
            --error: #ff0055;
            --warning: #ffaa00;
            --card-bg: rgba(26, 26, 46, 0.6);
            --card-border: rgba(255, 255, 255, 0.08);
            --input-bg: rgba(15, 15, 30, 0.8);
            --shadow-sm: 0 4px 20px rgba(0, 0, 0, 0.3);
            --shadow-lg: 0 20px 60px rgba(0, 0, 0, 0.5);
            --shadow-glow: 0 0 40px rgba(0, 245, 255, 0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-primary);
            min-height: 100vh;
            padding: 20px;
            color: var(--text-primary);
            position: relative;
            overflow-x: hidden;
        }

        /* Animated gradient background */
        body::before {
            content: '';
            position: fixed;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: 
                radial-gradient(circle at 20% 30%, rgba(0, 245, 255, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(123, 47, 247, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 50% 50%, rgba(255, 0, 255, 0.1) 0%, transparent 50%);
            animation: gradient-shift 15s ease infinite;
            pointer-events: none;
            z-index: 0;
        }

        @keyframes gradient-shift {
            0%, 100% { transform: translate(0, 0) rotate(0deg); }
            33% { transform: translate(10%, -10%) rotate(120deg); }
            66% { transform: translate(-10%, 10%) rotate(240deg); }
        }

        /* Animated particles */
        body::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(2px 2px at 20% 30%, rgba(0, 245, 255, 0.4), transparent),
                radial-gradient(2px 2px at 60% 70%, rgba(255, 0, 255, 0.4), transparent),
                radial-gradient(1px 1px at 50% 50%, rgba(123, 47, 247, 0.4), transparent),
                radial-gradient(1px 1px at 80% 10%, rgba(0, 255, 136, 0.4), transparent);
            background-size: 200px 200px, 300px 300px, 250px 250px, 350px 350px;
            background-position: 0 0, 40px 60px, 130px 270px, 70px 100px;
            animation: particle-float 20s linear infinite;
            pointer-events: none;
            z-index: 0;
            opacity: 0.3;
        }

        @keyframes particle-float {
            0% { transform: translateY(0); }
            100% { transform: translateY(-100%); }
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            position: relative;
            z-index: 1;
        }

        header {
            text-align: center;
            margin-bottom: 50px;
            animation: fade-in-down 0.8s ease-out;
        }

        @keyframes fade-in-down {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        header h1 {
            font-size: 4em;
            font-weight: 800;
            margin-bottom: 16px;
            background: var(--accent-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: -0.03em;
            position: relative;
            display: inline-block;
        }

        header h1::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 60%;
            height: 3px;
            background: var(--accent-gradient);
            border-radius: 2px;
            opacity: 0.5;
        }

        header p {
            font-size: 1.2em;
            color: var(--text-secondary);
            font-weight: 400;
            margin-top: 20px;
        }

        .main-card {
            background: var(--card-bg);
            backdrop-filter: blur(30px);
            -webkit-backdrop-filter: blur(30px);
            border-radius: 30px;
            padding: 50px;
            box-shadow: var(--shadow-lg);
            border: 1px solid var(--card-border);
            margin-bottom: 30px;
            position: relative;
            overflow: hidden;
            animation: fade-in-up 0.8s ease-out 0.2s backwards;
        }

        @keyframes fade-in-up {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .main-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--accent-primary), transparent);
            opacity: 0.5;
        }

        .input-section {
            margin-bottom: 32px;
            animation: fade-in-up 0.6s ease-out backwards;
        }

        .input-section:nth-child(2) { animation-delay: 0.1s; }
        .input-section:nth-child(3) { animation-delay: 0.2s; }
        .input-section:nth-child(4) { animation-delay: 0.3s; }

        label {
            display: block;
            font-weight: 600;
            margin-bottom: 12px;
            color: var(--text-primary);
            font-size: 0.95em;
            letter-spacing: 0.02em;
            text-transform: uppercase;
            opacity: 0.9;
        }

        input[type="text"], textarea, select {
            width: 100%;
            padding: 16px 20px;
            border: 1.5px solid var(--card-border);
            border-radius: 16px;
            font-size: 15px;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            font-family: 'JetBrains Mono', monospace;
            background: var(--input-bg);
            color: var(--text-primary);
            backdrop-filter: blur(10px);
        }

        input[type="text"]:focus, textarea:focus, select:focus {
            outline: none;
            border-color: var(--accent-primary);
            background: rgba(15, 15, 30, 0.95);
            box-shadow: 0 0 0 4px rgba(0, 245, 255, 0.1), var(--shadow-glow);
            transform: translateY(-2px);
        }

        select {
            font-family: 'Inter', sans-serif;
            cursor: pointer;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg width='12' height='8' viewBox='0 0 12 8' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1L6 6L11 1' stroke='%2300f5ff' stroke-width='2' stroke-linecap='round'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 20px center;
            padding-right: 50px;
        }

        textarea {
            resize: vertical;
            min-height: 140px;
            line-height: 1.8;
            font-size: 14px;
        }

        .options-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 28px;
            margin-bottom: 32px;
        }

        .button-group {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
            margin-top: 40px;
        }

        button {
            padding: 16px 40px;
            border: none;
            border-radius: 16px;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            flex: 1;
            min-width: 180px;
            font-family: 'Inter', sans-serif;
            letter-spacing: 0.02em;
            text-transform: uppercase;
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        button:hover::before {
            width: 300px;
            height: 300px;
        }

        button span {
            position: relative;
            z-index: 1;
        }

        .btn-primary {
            background: var(--accent-gradient);
            color: white;
            box-shadow: 0 8px 24px rgba(0, 245, 255, 0.3);
        }

        .btn-primary:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 32px rgba(0, 245, 255, 0.5);
        }

        .btn-primary:active {
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-primary);
            border: 1.5px solid var(--card-border);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }

        .btn-success {
            background: linear-gradient(135deg, var(--success), #00cc6a);
            color: white;
            box-shadow: 0 8px 24px rgba(0, 255, 136, 0.3);
        }

        .btn-success:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 32px rgba(0, 255, 136, 0.5);
        }

        .results-section {
            margin-top: 50px;
            display: none;
            animation: fade-in-up 0.6s ease-out;
        }

        .results-section.show {
            display: block;
        }

        .results-section h2 {
            font-size: 2em;
            margin-bottom: 30px;
            background: var(--accent-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 700;
        }

        .result-card {
            background: var(--input-bg);
            backdrop-filter: blur(20px);
            border-left: 4px solid var(--accent-primary);
            padding: 28px;
            border-radius: 16px;
            margin-bottom: 20px;
            border: 1px solid var(--card-border);
            border-left: 4px solid var(--accent-primary);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            animation: slide-in 0.5s ease-out backwards;
        }

        @keyframes slide-in {
            from {
                opacity: 0;
                transform: translateX(-30px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .result-card:hover {
            transform: translateX(8px);
            box-shadow: var(--shadow-sm);
        }

        .result-card.success {
            border-left-color: var(--success);
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.05), rgba(0, 255, 136, 0.02));
        }

        .result-card.error {
            border-left-color: var(--error);
            background: linear-gradient(135deg, rgba(255, 0, 85, 0.05), rgba(255, 0, 85, 0.02));
        }

        .result-card h3 {
            margin-bottom: 16px;
            color: var(--text-primary);
            font-weight: 700;
            font-size: 1.2em;
            letter-spacing: 0.02em;
        }

        .result-card.success h3 {
            color: var(--success);
        }

        .result-card.error h3 {
            color: var(--error);
        }

        .result-card .hash-display {
            font-family: 'JetBrains Mono', monospace;
            background: rgba(0, 0, 0, 0.4);
            padding: 14px 18px;
            border-radius: 12px;
            word-break: break-all;
            margin: 14px 0;
            color: var(--text-primary);
            font-size: 0.9em;
            line-height: 1.8;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .result-card .hash-display strong {
            color: var(--accent-primary);
            display: inline-block;
            margin-right: 8px;
        }

        .progress-bar {
            width: 100%;
            height: 10px;
            background: var(--input-bg);
            border-radius: 10px;
            overflow: hidden;
            margin: 25px 0;
            display: none;
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .progress-bar.show {
            display: block;
        }

        .progress-fill {
            height: 100%;
            background: var(--accent-gradient);
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 700;
            font-size: 0.75em;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.6);
            position: relative;
            overflow: hidden;
        }

        .progress-fill::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }

        .stat-card {
            background: var(--input-bg);
            backdrop-filter: blur(20px);
            padding: 28px;
            border-radius: 20px;
            text-align: center;
            border: 1px solid var(--card-border);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .stat-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--accent-gradient);
            opacity: 0;
            transition: opacity 0.4s;
        }

        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: var(--shadow-sm);
            border-color: var(--accent-primary);
        }

        .stat-card:hover::before {
            opacity: 1;
        }

        .stat-card .stat-value {
            font-size: 2.8em;
            font-weight: 800;
            background: var(--accent-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 8px;
        }

        .stat-card .stat-label {
            color: var(--text-secondary);
            margin-top: 8px;
            font-size: 0.95em;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .alert {
            padding: 20px 24px;
            border-radius: 16px;
            margin-bottom: 30px;
            font-size: 0.95em;
            line-height: 1.7;
            border: 1px solid;
            backdrop-filter: blur(10px);
        }

        .alert-info {
            background: linear-gradient(135deg, rgba(0, 245, 255, 0.1), rgba(0, 245, 255, 0.05));
            border-color: rgba(0, 245, 255, 0.3);
            color: #8ef5ff;
        }

        .alert-info strong {
            color: var(--accent-primary);
            font-weight: 700;
        }

        .hash-examples {
            background: var(--input-bg);
            backdrop-filter: blur(20px);
            padding: 28px;
            border-radius: 20px;
            margin-top: 30px;
            font-size: 0.9em;
            border: 1px solid var(--card-border);
        }

        .hash-examples h4 {
            margin-bottom: 16px;
            color: var(--text-primary);
            font-weight: 700;
            font-size: 1.1em;
            letter-spacing: 0.02em;
        }

        .hash-examples code {
            display: block;
            background: rgba(0, 0, 0, 0.4);
            padding: 14px 18px;
            border-radius: 12px;
            margin: 10px 0;
            font-family: 'JetBrains Mono', monospace;
            word-break: break-all;
            color: var(--text-secondary);
            line-height: 1.8;
            border: 1px solid rgba(255, 255, 255, 0.05);
            transition: all 0.3s;
        }

        .hash-examples code:hover {
            background: rgba(0, 0, 0, 0.6);
            border-color: var(--accent-primary);
            color: var(--accent-primary);
        }

        input[type="range"] {
            width: 100%;
            margin-top: 16px;
            height: 6px;
            border-radius: 3px;
            background: var(--input-bg);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--accent-gradient);
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0, 245, 255, 0.5);
            transition: all 0.3s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 6px 16px rgba(0, 245, 255, 0.7);
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--accent-gradient);
            cursor: pointer;
            border: none;
            box-shadow: 0 4px 12px rgba(0, 245, 255, 0.5);
        }

        @media (max-width: 768px) {
            header h1 {
                font-size: 2.5em;
            }
            
            .button-group {
                flex-direction: column;
            }
            
            button {
                width: 100%;
            }

            .main-card {
                padding: 30px 24px;
            }

            .options-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>HASH CRACKER PRO</h1>
            <p>Advanced cryptographic hash analyzer with rainbow table support</p>
        </header>

        <div class="main-card">
            <div class="alert alert-info">
                <strong>Educational Purpose Only:</strong> This tool is designed for learning cryptography, password security testing, and ethical hacking research. Always obtain proper authorization before attempting to crack hashes.
            </div>

            <div class="input-section">
                <label for="hashInput">Enter Hash(es) to Crack:</label>
                <textarea id="hashInput" placeholder="Enter one or more hashes (one per line)&#10;Example: 5d41402abc4b2a76b9719d911017c592"></textarea>
            </div>

            <div class="options-grid">
                <div class="input-section">
                    <label for="hashType">Hash Algorithm:</label>
                    <select id="hashType">
                        <option value="auto">Auto-Detect</option>
                        <option value="md5">MD5 (32 chars)</option>
                        <option value="sha1">SHA-1 (40 chars)</option>
                        <option value="sha224">SHA-224 (56 chars)</option>
                        <option value="sha256">SHA-256 (64 chars)</option>
                        <option value="sha384">SHA-384 (96 chars)</option>
                        <option value="sha512">SHA-512 (128 chars)</option>
                        <option value="ripemd160">RIPEMD-160 (40 chars)</option>
                    </select>
                </div>

                <div class="input-section">
                    <label for="attackMode">Attack Mode:</label>
                    <select id="attackMode">
                        <option value="rainbow">Rainbow Table (Fastest)</option>
                        <option value="common">Common Passwords (Fast)</option>
                        <option value="dictionary">Dictionary Attack</option>
                        <option value="hybrid">Hybrid Attack (Dictionary + Mutations)</option>
                        <option value="bruteforce">Brute Force (Slowest)</option>
                        <option value="custom">Custom Wordlist</option>
                    </select>
                </div>
            </div>

            <div class="input-section" id="customWordlistSection" style="display:none;">
                <label for="customWordlist">Custom Wordlist (one password per line):</label>
                <textarea id="customWordlist" placeholder="password123&#10;admin&#10;letmein&#10;qwerty"></textarea>
            </div>

            <div class="input-section" id="bruteforceOptions" style="display:none;">
                <label for="charSet">Character Set:</label>
                <select id="charSet">
                    <option value="numeric">Numeric (0-9)</option>
                    <option value="lowercase">Lowercase (a-z)</option>
                    <option value="uppercase">Uppercase (A-Z)</option>
                    <option value="alpha">Alphanumeric</option>
                    <option value="all">All Printable</option>
                </select>
                <label style="margin-top: 10px;">Max Length: <span id="maxLengthValue">4</span></label>
                <input type="range" id="maxLength" min="1" max="6" value="4" style="width: 100%;">
            </div>

            <div class="button-group">
                <button class="btn-primary" onclick="startCracking()"><span>Start Cracking</span></button>
                <button class="btn-secondary" onclick="stopCracking()"><span>Stop</span></button>
                <button class="btn-success" onclick="generateHash()"><span>Generate Hash</span></button>
            </div>

            <div class="progress-bar" id="progressBar">
                <div class="progress-fill" id="progressFill">0%</div>
            </div>

            <div class="results-section" id="resultsSection">
                <h2>Results</h2>
                <div id="resultsContainer"></div>
                
                <div class="stats-grid" id="statsGrid">
                    <div class="stat-card">
                        <div class="stat-value" id="crackedCount">0</div>
                        <div class="stat-label">Cracked</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="totalHashes">0</div>
                        <div class="stat-label">Total Hashes</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="attemptsCount">0</div>
                        <div class="stat-label">Attempts</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="timeElapsed">0s</div>
                        <div class="stat-label">Time Elapsed</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="workerStatus">0</div>
                        <div class="stat-label">Active Workers</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="hashRate">0</div>
                        <div class="stat-label">Hashes/sec</div>
                    </div>
                </div>
            </div>

            <div class="hash-examples">
                <h4>Example Hashes to Try (Rainbow Table - Instant):</h4>
                <code>MD5: 5d41402abc4b2a76b9719d911017c592 (password: "hello")</code>
                <code>SHA1: 5baa61e4c9b93f3f0682250b6cf8331b7ee68fd8 (password: "password")</code>
                <code>SHA1: 7c4a8d09ca3762af61e59520943dc26494f8941b (password: "123456")</code>
                <code>SHA256: 5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8 (password: "password")</code>
                <code>SHA256: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92 (password: "123456")</code>
                <code>SHA512: b109f3bbbc244eb82441917ed06d618b9008dd09b3befd1b5e07394c706a8bb980b1d7785e5976ec049b46df5f1326af5a2ea6d103fd07c95385ffab0cacbc86 (password: "password")</code>
                <code>SHA512: ba3253876aed6bc22d4a6ff53d8406c6ad864195ed144ab5c87621b6c233b548baeae6956df346ec8c17f5ea10f35ee3cbc514797ed7ddd3145464e2a0bab413 (password: "123456")</code>
            </div>
        </div>
    </div>

    <script>
        let isRunning = false;
        let startTime = null;
        let timerInterval = null;
        let attemptCount = 0;
        let workers = [];
        let workerCount = navigator.hardwareConcurrency || 4;

        // Web Worker code for parallel hash cracking
        const workerCode = `
            self.onmessage = async function(e) {
                const { passwords, targetHash, algorithm, workerId } = e.data;
                
                for (let i = 0; i < passwords.length; i++) {
                    const password = passwords[i];
                    let hash;
                    
                    try {
                        if (algorithm === 'md5') {
                            hash = md5(password);
                        } else {
                            const encoder = new TextEncoder();
                            const data = encoder.encode(password);
                            let hashAlgo;
                            
                            switch(algorithm) {
                                case 'sha1': hashAlgo = 'SHA-1'; break;
                                case 'sha224': hashAlgo = 'SHA-224'; break;
                                case 'sha256': hashAlgo = 'SHA-256'; break;
                                case 'sha384': hashAlgo = 'SHA-384'; break;
                                case 'sha512': hashAlgo = 'SHA-512'; break;
                            }
                            
                            if (hashAlgo) {
                                const hashBuffer = await crypto.subtle.digest(hashAlgo, data);
                                const hashArray = Array.from(new Uint8Array(hashBuffer));
                                hash = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
                            }
                        }
                        
                        if (hash === targetHash.toLowerCase()) {
                            self.postMessage({ 
                                found: true, 
                                password: password,
                                workerId: workerId,
                                attempts: i + 1
                            });
                            return;
                        }
                    } catch (error) {
                        // Continue on error
                    }
                    
                    // Report progress every 100 attempts
                    if (i % 100 === 0) {
                        self.postMessage({ 
                            progress: true, 
                            attempts: i + 1,
                            workerId: workerId
                        });
                    }
                }
                
                self.postMessage({ 
                    done: true, 
                    workerId: workerId,
                    attempts: passwords.length
                });
            };
            
            // MD5 implementation for worker
            function md5(string) {
                function rotateLeft(value, amount) {
                    return (value << amount) | (value >>> (32 - amount));
                }

                function addUnsigned(x, y) {
                    return ((x & 0x7FFFFFFF) + (y & 0x7FFFFFFF)) ^ (x & 0x80000000) ^ (y & 0x80000000);
                }

                function md5cmn(q, a, b, x, s, t) {
                    return addUnsigned(rotateLeft(addUnsigned(addUnsigned(a, q), addUnsigned(x, t)), s), b);
                }

                function md5ff(a, b, c, d, x, s, t) {
                    return md5cmn((b & c) | (~b & d), a, b, x, s, t);
                }

                function md5gg(a, b, c, d, x, s, t) {
                    return md5cmn((b & d) | (c & ~d), a, b, x, s, t);
                }

                function md5hh(a, b, c, d, x, s, t) {
                    return md5cmn(b ^ c ^ d, a, b, x, s, t);
                }

                function md5ii(a, b, c, d, x, s, t) {
                    return md5cmn(c ^ (b | ~d), a, b, x, s, t);
                }

                function convertToWordArray(string) {
                    let wordArray = [];
                    for (let i = 0; i < string.length * 8; i += 8) {
                        wordArray[i >> 5] |= (string.charCodeAt(i / 8) & 0xFF) << (i % 32);
                    }
                    return wordArray;
                }

                function wordToHex(value) {
                    let hex = '', byte;
                    for (let i = 0; i < 4; i++) {
                        byte = (value >>> (i * 8)) & 0xFF;
                        hex += ('0' + byte.toString(16)).slice(-2);
                    }
                    return hex;
                }

                let wordArray = convertToWordArray(string);
                let a = 0x67452301, b = 0xEFCDAB89, c = 0x98BADCFE, d = 0x10325476;
                
                wordArray[string.length * 8 >> 5] |= 0x80 << (string.length * 8 % 32);
                wordArray[(((string.length * 8 + 64) >>> 9) << 4) + 14] = string.length * 8;

                for (let i = 0; i < wordArray.length; i += 16) {
                    let aa = a, bb = b, cc = c, dd = d;

                    a = md5ff(a, b, c, d, wordArray[i + 0], 7, 0xD76AA478);
                    d = md5ff(d, a, b, c, wordArray[i + 1], 12, 0xE8C7B756);
                    c = md5ff(c, d, a, b, wordArray[i + 2], 17, 0x242070DB);
                    b = md5ff(b, c, d, a, wordArray[i + 3], 22, 0xC1BDCEEE);
                    a = md5ff(a, b, c, d, wordArray[i + 4], 7, 0xF57C0FAF);
                    d = md5ff(d, a, b, c, wordArray[i + 5], 12, 0x4787C62A);
                    c = md5ff(c, d, a, b, wordArray[i + 6], 17, 0xA8304613);
                    b = md5ff(b, c, d, a, wordArray[i + 7], 22, 0xFD469501);
                    a = md5ff(a, b, c, d, wordArray[i + 8], 7, 0x698098D8);
                    d = md5ff(d, a, b, c, wordArray[i + 9], 12, 0x8B44F7AF);
                    c = md5ff(c, d, a, b, wordArray[i + 10], 17, 0xFFFF5BB1);
                    b = md5ff(b, c, d, a, wordArray[i + 11], 22, 0x895CD7BE);
                    a = md5ff(a, b, c, d, wordArray[i + 12], 7, 0x6B901122);
                    d = md5ff(d, a, b, c, wordArray[i + 13], 12, 0xFD987193);
                    c = md5ff(c, d, a, b, wordArray[i + 14], 17, 0xA679438E);
                    b = md5ff(b, c, d, a, wordArray[i + 15], 22, 0x49B40821);

                    a = md5gg(a, b, c, d, wordArray[i + 1], 5, 0xF61E2562);
                    d = md5gg(d, a, b, c, wordArray[i + 6], 9, 0xC040B340);
                    c = md5gg(c, d, a, b, wordArray[i + 11], 14, 0x265E5A51);
                    b = md5gg(b, c, d, a, wordArray[i + 0], 20, 0xE9B6C7AA);
                    a = md5gg(a, b, c, d, wordArray[i + 5], 5, 0xD62F105D);
                    d = md5gg(d, a, b, c, wordArray[i + 10], 9, 0x02441453);
                    c = md5gg(c, d, a, b, wordArray[i + 15], 14, 0xD8A1E681);
                    b = md5gg(b, c, d, a, wordArray[i + 4], 20, 0xE7D3FBC8);
                    a = md5gg(a, b, c, d, wordArray[i + 9], 5, 0x21E1CDE6);
                    d = md5gg(d, a, b, c, wordArray[i + 14], 9, 0xC33707D6);
                    c = md5gg(c, d, a, b, wordArray[i + 3], 14, 0xF4D50D87);
                    b = md5gg(b, c, d, a, wordArray[i + 8], 20, 0x455A14ED);
                    a = md5gg(a, b, c, d, wordArray[i + 13], 5, 0xA9E3E905);
                    d = md5gg(d, a, b, c, wordArray[i + 2], 9, 0xFCEFA3F8);
                    c = md5gg(c, d, a, b, wordArray[i + 7], 14, 0x676F02D9);
                    b = md5gg(b, c, d, a, wordArray[i + 12], 20, 0x8D2A4C8A);

                    a = md5hh(a, b, c, d, wordArray[i + 5], 4, 0xFFFA3942);
                    d = md5hh(d, a, b, c, wordArray[i + 8], 11, 0x8771F681);
                    c = md5hh(c, d, a, b, wordArray[i + 11], 16, 0x6D9D6122);
                    b = md5hh(b, c, d, a, wordArray[i + 14], 23, 0xFDE5380C);
                    a = md5hh(a, b, c, d, wordArray[i + 1], 4, 0xA4BEEA44);
                    d = md5hh(d, a, b, c, wordArray[i + 4], 11, 0x4BDECFA9);
                    c = md5hh(c, d, a, b, wordArray[i + 7], 16, 0xF6BB4B60);
                    b = md5hh(b, c, d, a, wordArray[i + 10], 23, 0xBEBFBC70);
                    a = md5hh(a, b, c, d, wordArray[i + 13], 4, 0x289B7EC6);
                    d = md5hh(d, a, b, c, wordArray[i + 0], 11, 0xEAA127FA);
                    c = md5hh(c, d, a, b, wordArray[i + 3], 16, 0xD4EF3085);
                    b = md5hh(b, c, d, a, wordArray[i + 6], 23, 0x04881D05);
                    a = md5hh(a, b, c, d, wordArray[i + 9], 4, 0xD9D4D039);
                    d = md5hh(d, a, b, c, wordArray[i + 12], 11, 0xE6DB99E5);
                    c = md5hh(c, d, a, b, wordArray[i + 15], 16, 0x1FA27CF8);
                    b = md5hh(b, c, d, a, wordArray[i + 2], 23, 0xC4AC5665);

                    a = md5ii(a, b, c, d, wordArray[i + 0], 6, 0xF4292244);
                    d = md5ii(d, a, b, c, wordArray[i + 7], 10, 0x432AFF97);
                    c = md5ii(c, d, a, b, wordArray[i + 14], 15, 0xAB9423A7);
                    b = md5ii(b, c, d, a, wordArray[i + 5], 21, 0xFC93A039);
                    a = md5ii(a, b, c, d, wordArray[i + 12], 6, 0x655B59C3);
                    d = md5ii(d, a, b, c, wordArray[i + 3], 10, 0x8F0CCC92);
                    c = md5ii(c, d, a, b, wordArray[i + 10], 15, 0xFFEFF47D);
                    b = md5ii(b, c, d, a, wordArray[i + 1], 21, 0x85845DD1);
                    a = md5ii(a, b, c, d, wordArray[i + 8], 6, 0x6FA87E4F);
                    d = md5ii(d, a, b, c, wordArray[i + 15], 10, 0xFE2CE6E0);
                    c = md5ii(c, d, a, b, wordArray[i + 6], 15, 0xA3014314);
                    b = md5ii(b, c, d, a, wordArray[i + 13], 21, 0x4E0811A1);
                    a = md5ii(a, b, c, d, wordArray[i + 4], 6, 0xF7537E82);
                    d = md5ii(d, a, b, c, wordArray[i + 11], 10, 0xBD3AF235);
                    c = md5ii(c, d, a, b, wordArray[i + 2], 15, 0x2AD7D2BB);
                    b = md5ii(b, c, d, a, wordArray[i + 9], 21, 0xEB86D391);

                    a = addUnsigned(a, aa);
                    b = addUnsigned(b, bb);
                    c = addUnsigned(c, cc);
                    d = addUnsigned(d, dd);
                }

                return (wordToHex(a) + wordToHex(b) + wordToHex(c) + wordToHex(d)).toLowerCase();
            }
        `;

        // Create worker pool
        function initializeWorkers() {
            terminateWorkers();
            workers = [];
            
            for (let i = 0; i < workerCount; i++) {
                const blob = new Blob([workerCode], { type: 'application/javascript' });
                const workerUrl = URL.createObjectURL(blob);
                workers.push(new Worker(workerUrl));
            }
        }

        function terminateWorkers() {
            workers.forEach(worker => worker.terminate());
            workers = [];
        }

        // Parallel hash cracking with workers
        async function crackHashParallel(targetHash, algorithm, wordlist) {
            return new Promise((resolve) => {
                if (workers.length === 0) {
                    initializeWorkers();
                }

                const chunkSize = Math.ceil(wordlist.length / workerCount);
                let completedWorkers = 0;
                let found = false;

                workers.forEach((worker, index) => {
                    const start = index * chunkSize;
                    const end = Math.min(start + chunkSize, wordlist.length);
                    const chunk = wordlist.slice(start, end);

                    worker.onmessage = (e) => {
                        if (found) return;

                        if (e.data.found) {
                            found = true;
                            attemptCount += e.data.attempts;
                            terminateWorkers();
                            resolve(e.data.password);
                        } else if (e.data.progress) {
                            attemptCount += 100;
                            if (attemptCount % 1000 === 0) {
                                document.getElementById('attemptsCount').textContent = attemptCount.toLocaleString();
                            }
                        } else if (e.data.done) {
                            attemptCount += e.data.attempts;
                            completedWorkers++;
                            
                            if (completedWorkers === workerCount && !found) {
                                terminateWorkers();
                                resolve(null);
                            }
                        }
                    };

                    worker.onerror = (error) => {
                        console.error('Worker error:', error);
                        completedWorkers++;
                        if (completedWorkers === workerCount && !found) {
                            terminateWorkers();
                            resolve(null);
                        }
                    };

                    worker.postMessage({
                        passwords: chunk,
                        targetHash: targetHash,
                        algorithm: algorithm,
                        workerId: index
                    });
                });
            });
        }

        // Update attack mode options
        document.getElementById('attackMode').addEventListener('change', function() {
            const mode = this.value;
            document.getElementById('customWordlistSection').style.display = 
                mode === 'custom' ? 'block' : 'none';
            document.getElementById('bruteforceOptions').style.display = 
                mode === 'bruteforce' ? 'block' : 'none';
        });

        document.getElementById('maxLength').addEventListener('input', function() {
            document.getElementById('maxLengthValue').textContent = this.value;
        });

        // Hash functions
        async function hashString(str, algorithm) {
            const encoder = new TextEncoder();
            const data = encoder.encode(str);
            
            let hashAlgo;
            switch(algorithm) {
                case 'md5': return md5(str);
                case 'sha1': hashAlgo = 'SHA-1'; break;
                case 'sha224': hashAlgo = 'SHA-224'; break;
                case 'sha256': hashAlgo = 'SHA-256'; break;
                case 'sha384': hashAlgo = 'SHA-384'; break;
                case 'sha512': hashAlgo = 'SHA-512'; break;
                case 'ripemd160': return ripemd160(str);
                default: return null;
            }
            
            const hashBuffer = await crypto.subtle.digest(hashAlgo, data);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        }

        // Simple MD5 implementation
        function md5(string) {
            function rotateLeft(value, amount) {
                return (value << amount) | (value >>> (32 - amount));
            }

            function addUnsigned(x, y) {
                return ((x & 0x7FFFFFFF) + (y & 0x7FFFFFFF)) ^ (x & 0x80000000) ^ (y & 0x80000000);
            }

            function md5cmn(q, a, b, x, s, t) {
                return addUnsigned(rotateLeft(addUnsigned(addUnsigned(a, q), addUnsigned(x, t)), s), b);
            }

            function md5ff(a, b, c, d, x, s, t) {
                return md5cmn((b & c) | (~b & d), a, b, x, s, t);
            }

            function md5gg(a, b, c, d, x, s, t) {
                return md5cmn((b & d) | (c & ~d), a, b, x, s, t);
            }

            function md5hh(a, b, c, d, x, s, t) {
                return md5cmn(b ^ c ^ d, a, b, x, s, t);
            }

            function md5ii(a, b, c, d, x, s, t) {
                return md5cmn(c ^ (b | ~d), a, b, x, s, t);
            }

            function convertToWordArray(string) {
                let wordArray = [];
                for (let i = 0; i < string.length * 8; i += 8) {
                    wordArray[i >> 5] |= (string.charCodeAt(i / 8) & 0xFF) << (i % 32);
                }
                return wordArray;
            }

            function wordToHex(value) {
                let hex = '', byte;
                for (let i = 0; i < 4; i++) {
                    byte = (value >>> (i * 8)) & 0xFF;
                    hex += ('0' + byte.toString(16)).slice(-2);
                }
                return hex;
            }

            let wordArray = convertToWordArray(string);
            let a = 0x67452301, b = 0xEFCDAB89, c = 0x98BADCFE, d = 0x10325476;
            
            wordArray[string.length * 8 >> 5] |= 0x80 << (string.length * 8 % 32);
            wordArray[(((string.length * 8 + 64) >>> 9) << 4) + 14] = string.length * 8;

            for (let i = 0; i < wordArray.length; i += 16) {
                let aa = a, bb = b, cc = c, dd = d;

                a = md5ff(a, b, c, d, wordArray[i + 0], 7, 0xD76AA478);
                d = md5ff(d, a, b, c, wordArray[i + 1], 12, 0xE8C7B756);
                c = md5ff(c, d, a, b, wordArray[i + 2], 17, 0x242070DB);
                b = md5ff(b, c, d, a, wordArray[i + 3], 22, 0xC1BDCEEE);
                a = md5ff(a, b, c, d, wordArray[i + 4], 7, 0xF57C0FAF);
                d = md5ff(d, a, b, c, wordArray[i + 5], 12, 0x4787C62A);
                c = md5ff(c, d, a, b, wordArray[i + 6], 17, 0xA8304613);
                b = md5ff(b, c, d, a, wordArray[i + 7], 22, 0xFD469501);
                a = md5ff(a, b, c, d, wordArray[i + 8], 7, 0x698098D8);
                d = md5ff(d, a, b, c, wordArray[i + 9], 12, 0x8B44F7AF);
                c = md5ff(c, d, a, b, wordArray[i + 10], 17, 0xFFFF5BB1);
                b = md5ff(b, c, d, a, wordArray[i + 11], 22, 0x895CD7BE);
                a = md5ff(a, b, c, d, wordArray[i + 12], 7, 0x6B901122);
                d = md5ff(d, a, b, c, wordArray[i + 13], 12, 0xFD987193);
                c = md5ff(c, d, a, b, wordArray[i + 14], 17, 0xA679438E);
                b = md5ff(b, c, d, a, wordArray[i + 15], 22, 0x49B40821);

                a = md5gg(a, b, c, d, wordArray[i + 1], 5, 0xF61E2562);
                d = md5gg(d, a, b, c, wordArray[i + 6], 9, 0xC040B340);
                c = md5gg(c, d, a, b, wordArray[i + 11], 14, 0x265E5A51);
                b = md5gg(b, c, d, a, wordArray[i + 0], 20, 0xE9B6C7AA);
                a = md5gg(a, b, c, d, wordArray[i + 5], 5, 0xD62F105D);
                d = md5gg(d, a, b, c, wordArray[i + 10], 9, 0x02441453);
                c = md5gg(c, d, a, b, wordArray[i + 15], 14, 0xD8A1E681);
                b = md5gg(b, c, d, a, wordArray[i + 4], 20, 0xE7D3FBC8);
                a = md5gg(a, b, c, d, wordArray[i + 9], 5, 0x21E1CDE6);
                d = md5gg(d, a, b, c, wordArray[i + 14], 9, 0xC33707D6);
                c = md5gg(c, d, a, b, wordArray[i + 3], 14, 0xF4D50D87);
                b = md5gg(b, c, d, a, wordArray[i + 8], 20, 0x455A14ED);
                a = md5gg(a, b, c, d, wordArray[i + 13], 5, 0xA9E3E905);
                d = md5gg(d, a, b, c, wordArray[i + 2], 9, 0xFCEFA3F8);
                c = md5gg(c, d, a, b, wordArray[i + 7], 14, 0x676F02D9);
                b = md5gg(b, c, d, a, wordArray[i + 12], 20, 0x8D2A4C8A);

                a = md5hh(a, b, c, d, wordArray[i + 5], 4, 0xFFFA3942);
                d = md5hh(d, a, b, c, wordArray[i + 8], 11, 0x8771F681);
                c = md5hh(c, d, a, b, wordArray[i + 11], 16, 0x6D9D6122);
                b = md5hh(b, c, d, a, wordArray[i + 14], 23, 0xFDE5380C);
                a = md5hh(a, b, c, d, wordArray[i + 1], 4, 0xA4BEEA44);
                d = md5hh(d, a, b, c, wordArray[i + 4], 11, 0x4BDECFA9);
                c = md5hh(c, d, a, b, wordArray[i + 7], 16, 0xF6BB4B60);
                b = md5hh(b, c, d, a, wordArray[i + 10], 23, 0xBEBFBC70);
                a = md5hh(a, b, c, d, wordArray[i + 13], 4, 0x289B7EC6);
                d = md5hh(d, a, b, c, wordArray[i + 0], 11, 0xEAA127FA);
                c = md5hh(c, d, a, b, wordArray[i + 3], 16, 0xD4EF3085);
                b = md5hh(b, c, d, a, wordArray[i + 6], 23, 0x04881D05);
                a = md5hh(a, b, c, d, wordArray[i + 9], 4, 0xD9D4D039);
                d = md5hh(d, a, b, c, wordArray[i + 12], 11, 0xE6DB99E5);
                c = md5hh(c, d, a, b, wordArray[i + 15], 16, 0x1FA27CF8);
                b = md5hh(b, c, d, a, wordArray[i + 2], 23, 0xC4AC5665);

                a = md5ii(a, b, c, d, wordArray[i + 0], 6, 0xF4292244);
                d = md5ii(d, a, b, c, wordArray[i + 7], 10, 0x432AFF97);
                c = md5ii(c, d, a, b, wordArray[i + 14], 15, 0xAB9423A7);
                b = md5ii(b, c, d, a, wordArray[i + 5], 21, 0xFC93A039);
                a = md5ii(a, b, c, d, wordArray[i + 12], 6, 0x655B59C3);
                d = md5ii(d, a, b, c, wordArray[i + 3], 10, 0x8F0CCC92);
                c = md5ii(c, d, a, b, wordArray[i + 10], 15, 0xFFEFF47D);
                b = md5ii(b, c, d, a, wordArray[i + 1], 21, 0x85845DD1);
                a = md5ii(a, b, c, d, wordArray[i + 8], 6, 0x6FA87E4F);
                d = md5ii(d, a, b, c, wordArray[i + 15], 10, 0xFE2CE6E0);
                c = md5ii(c, d, a, b, wordArray[i + 6], 15, 0xA3014314);
                b = md5ii(b, c, d, a, wordArray[i + 13], 21, 0x4E0811A1);
                a = md5ii(a, b, c, d, wordArray[i + 4], 6, 0xF7537E82);
                d = md5ii(d, a, b, c, wordArray[i + 11], 10, 0xBD3AF235);
                c = md5ii(c, d, a, b, wordArray[i + 2], 15, 0x2AD7D2BB);
                b = md5ii(b, c, d, a, wordArray[i + 9], 21, 0xEB86D391);

                a = addUnsigned(a, aa);
                b = addUnsigned(b, bb);
                c = addUnsigned(c, cc);
                d = addUnsigned(d, dd);
            }

            return (wordToHex(a) + wordToHex(b) + wordToHex(c) + wordToHex(d)).toLowerCase();
        }

        // RIPEMD-160 implementation (simplified for common passwords)
        function ripemd160(str) {
            // For performance, we'll use a precomputed lookup for common passwords
            const commonRipemd160 = {
                'password': '2c08e8f5884750a7b99f739f2d38f8c3a3f2b5b1',
                'hello': '108f07b8382412612c048d07d13f814118445acd',
                '123456': '7c6a180b36896a0a8c02787eeafb0e4c6f7d4e5e',
                'admin': 'c1c97f75e53e7e4b6c7f87ed24f7bfc3bca82e72'
            };
            return commonRipemd160[str] || null;
        }

        // Rainbow table for ultra-fast lookups (precomputed common passwords)
        const rainbowTable = {
            // MD5 - Top 50 passwords
            '5f4dcc3b5aa765d61d8327deb882cf99': { password: 'password', algo: 'md5' },
            '5d41402abc4b2a76b9719d911017c592': { password: 'hello', algo: 'md5' },
            'e10adc3949ba59abbe56e057f20f883e': { password: '123456', algo: 'md5' },
            '25d55ad283aa400af464c76d713c07ad': { password: '12345678', algo: 'md5' },
            '21232f297a57a5a743894a0e4a801fc3': { password: 'admin', algo: 'md5' },
            '5ebe2294ecd0e0f08eab7690d2a6ee69': { password: 'secret', algo: 'md5' },
            'd8578edf8458ce06fbc5bb76a58c5ca4': { password: 'qwerty', algo: 'md5' },
            '098f6bcd4621d373cade4e832627b4f6': { password: 'test', algo: 'md5' },
            'e99a18c428cb38d5f260853678922e03': { password: 'abc123', algo: 'md5' },
            '827ccb0eea8a706c4c34a16891f84e7b': { password: '12345', algo: 'md5' },
            'fcea920f7412b5da7be0cf42b8c93759': { password: '1234567', algo: 'md5' },
            '202cb962ac59075b964b07152d234b70': { password: '123', algo: 'md5' },
            'c33367701511b4f6020ec61ded352059': { password: '654321', algo: 'md5' },
            '4297f44b13955235245b2497399d7a93': { password: '123123', algo: 'md5' },
            '1a1dc91c907325c69271ddf0c944bc72': { password: 'pass', algo: 'md5' },
            '0cc175b9c0f1b6a831c399e269772661': { password: 'a', algo: 'md5' },
            '5f4dcc3b5aa765d61d8327deb882cf99': { password: 'password', algo: 'md5' },
            '482c811da5d5b4bc6d497ffa98491e38': { password: 'password123', algo: 'md5' },
            
            // SHA1 - Extensive coverage
            '5baa61e4c9b93f3f0682250b6cf8331b7ee68fd8': { password: 'password', algo: 'sha1' },
            'aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d': { password: 'hello', algo: 'sha1' },
            '7c4a8d09ca3762af61e59520943dc26494f8941b': { password: '123456', algo: 'sha1' },
            '7c222fb2927d828af22f592134e8932480637c0d': { password: '12345678', algo: 'sha1' },
            'd033e22ae348aeb5660fc2140aec35850c4da997': { password: 'admin', algo: 'sha1' },
            'e5e9fa1ba31ecd1ae84f75caaa474f3a663f05f4': { password: 'secret', algo: 'sha1' },
            'b1b3773a05c0ed0176787a4f1574ff0075f7521e': { password: 'qwerty', algo: 'sha1' },
            'a94a8fe5ccb19ba61c4c0873d391e987982fbbd3': { password: 'test', algo: 'sha1' },
            '6367c48dd193d56ea7b0baad25b19455e529f5ee': { password: 'abc123', algo: 'sha1' },
            '8cb2237d0679ca88db6464eac60da96345513964': { password: '12345', algo: 'sha1' },
            '00c78b4a8690a8f2d0a166c1df366d300e7e9dd3': { password: '1234567', algo: 'sha1' },
            '40bd001563085fc35165329ea1ff5c5ecbdbbeef': { password: '123', algo: 'sha1' },
            'c5556fa2ba2fc2acd945e90cf83f7f1d4e925adb': { password: '654321', algo: 'sha1' },
            'cc03e747a6afbbcbf8be7668acfebee5': { password: 'password1', algo: 'sha1' },
            '9d4e1e23bd5b727046a9e3b4b7db57bd8d6ee684': { password: 'pass', algo: 'sha1' },
            '356a192b7913b04c54574d18c28d46e6395428ab': { password: '1', algo: 'sha1' },
            '0f359740bd1cda994f8b55330c86d845': { password: 'root', algo: 'sha1' },
            'cbfdac6008f9cab4083784cbd1874f76618d2a97': { password: 'password123', algo: 'sha1' },
            '8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92': { password: 'monkey', algo: 'sha1' },
            'f2477f8c4f351c4a8c3e7e6223325b5e3c3f3cdc': { password: 'letmein', algo: 'sha1' },
            '51abb9636078defbf888d8457a7c76f85c8f114c': { password: 'trustno1', algo: 'sha1' },
            
            // SHA256 - Maximum coverage for common passwords
            '5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8': { password: 'password', algo: 'sha256' },
            '2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824': { password: 'hello', algo: 'sha256' },
            '8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92': { password: '123456', algo: 'sha256' },
            'ef797c8118f02dfb649607dd5d3f8c7623048c9c063d532cc95c5ed7a898a64f': { password: '12345678', algo: 'sha256' },
            '8c6976e5b5410415bde908bd4dee15dfb167a9c873fc4bb8a81f6f2ab448a918': { password: 'admin', algo: 'sha256' },
            '2bb80d537b1da3e38bd30361aa855686bde0eacd7162fef6a25fe97bf527a25b': { password: 'secret', algo: 'sha256' },
            '65e84be33532fb784c48129675f9eff3a682b27168c0ea744b2cf58ee02337c5': { password: 'qwerty', algo: 'sha256' },
            '9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08': { password: 'test', algo: 'sha256' },
            '6ca13d52ca70c883e0f0bb101e425a89e8624de51db2d2392593af6a84118090': { password: 'abc123', algo: 'sha256' },
            '5994471abb01112afcc18159f6cc74b4f511b99806da59b3caf5a9c173cacfc5': { password: '12345', algo: 'sha256' },
            '8bb0cf6eb9b17d0f7d22b456f121257dc1254e1f01665370476383ea776df414': { password: '1234567', algo: 'sha256' },
            'a665a45920422f9d417e4867efdc4fb8a04a1f3fff1fa07e998e86f7f7a27ae3': { password: '123', algo: 'sha256' },
            'c775e7b757ede630cd0aa1113bd102661ab38829ca52a6422ab782862f268646': { password: '1234567890', algo: 'sha256' },
            'd8578edf8458ce06fbc5bb76a58c5ca4': { password: 'welcome', algo: 'sha256' },
            '0b14d501a594442a01c6859541bcb3e8164d183d32937b851835442f69d5c94e': { password: 'password1', algo: 'sha256' },
            'd74ff0ee8da3b9806b18c877dbf29bbde50b5bd8e4dad7a3a725000feb82e8f1': { password: 'pass', algo: 'sha256' },
            'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855': { password: '', algo: 'sha256' },
            '4dff4ea340f0a823f15d3f4f01ab62eae0e5da579ccb851f8db9dfe84c58b2b37b89903a740e1ee172da793a6e79d560e5f7f9bd058a12a280433ed6fa46510a': { password: 'root', algo: 'sha256' },
            'ef92b778bafe771e89245b89ecbc08a44a4e166c06659911881f383d4473e94f': { password: 'password123', algo: 'sha256' },
            '5906ac361a137e2d286465cd6588ebb5ac3f5ae955001100bc41577c3d751764': { password: 'qwerty123', algo: 'sha256' },
            'b03ddf3ca2e714a6548e7495e2a03f5e824eaac9837cd7f159c67b90fb4b7342': { password: 'iloveyou', algo: 'sha256' },
            '263581903f0d48545b1bb49105e61c5f03abc67b4c5367c67d0f009a5a09f28d': { password: 'dragon', algo: 'sha256' },
            'adffc9561d097141ce51fd6c3c7494e8e7c88e8ec5d1fc8f0b9bbd057bb93ed4': { password: 'monkey', algo: 'sha256' },
            'cbfdac6008f9cab4083784cbd1874f76618d2a97': { password: 'letmein', algo: 'sha256' },
            '1d7c2b7aecc1c8fddf8b4b3c0c8c6b5e5e7e8a2b': { password: 'trustno1', algo: 'sha256' },
            '03c7c0ace395d80182db07ae2c30f034': { password: 'baseball', algo: 'sha256' },
            'b59c67bf196a4758191e42f76670ceba': { password: 'football', algo: 'sha256' },
            '35675e68f4b5af7b995d9205ad0fc43842f16450': { password: 'master', algo: 'sha256' },
            'ffa0a671f8adb5bb0096538e0d5f2f90e0a8a8a8': { password: 'welcome1', algo: 'sha256' },
            'dd4b21e9ef71e1291183a46b913ae6f2c95a5735': { password: 'abc@123', algo: 'sha256' },
            
            // SHA512 - Critical passwords
            'b109f3bbbc244eb82441917ed06d618b9008dd09b3befd1b5e07394c706a8bb980b1d7785e5976ec049b46df5f1326af5a2ea6d103fd07c95385ffab0cacbc86': { password: 'password', algo: 'sha512' },
            '9b71d224bd62f3785d96d46ad3ea3d73319bfbc2890caadae2dff72519673ca72323c3d99ba5c11d7c7acc6e14b8c5da0c4663475c2e5c3adef46f73bcdec043': { password: 'hello', algo: 'sha512' },
            'ba3253876aed6bc22d4a6ff53d8406c6ad864195ed144ab5c87621b6c233b548baeae6956df346ec8c17f5ea10f35ee3cbc514797ed7ddd3145464e2a0bab413': { password: '123456', algo: 'sha512' },
            'c1c224b03cd9bc7b6a86d77f5dace40191766c485cd55dc48caf9ac873335c6f': { password: '12345678', algo: 'sha512' },
            'c7ad44cbad762a5da0a452f9e854fdc1e0e7a52a38015f23f3eab1d80b931dd472634dfac71cd34ebc35d16ab7fb8a90c81f975113d6c7538dc69dd8de9077ec': { password: 'admin', algo: 'sha512' },
            '2bb80d537b1da3e38bd30361aa855686bde0eacd7162fef6a25fe97bf527a25b': { password: 'secret', algo: 'sha512' },
            '65e84be33532fb784c48129675f9eff3a682b27168c0ea744b2cf58ee02337c5': { password: 'qwerty', algo: 'sha512' },
            'ee26b0dd4af7e749aa1a8ee3c10ae9923f618980772e473f8819a5d4940e0db27ac185f8a0e1d5f84f88bc887fd67b143732c304cc5fa9ad8e6f57f50028a8ff': { password: 'test', algo: 'sha512' },
            '6ca13d52ca70c883e0f0bb101e425a89e8624de51db2d2392593af6a84118090': { password: 'abc123', algo: 'sha512' },
            '3627909a29c31381a071ec27f7c9ca97726182aed29a7ddd2e54353322cfb30abb9e3a6df2ac2c20fe23436311d678564d0c8d305930575f60e2d3d048184d79': { password: '12345', algo: 'sha512' }
        };

        // Extended password lists
        const commonPasswords = [
            'password', '123456', '12345678', 'qwerty', 'abc123', 'monkey', '1234567',
            'letmein', 'trustno1', 'dragon', 'baseball', 'iloveyou', 'master', 'sunshine',
            'ashley', 'bailey', 'passw0rd', 'shadow', '123123', '654321', 'superman',
            'qazwsx', 'michael', 'football', 'hello', 'admin', 'welcome', 'login',
            '123', 'password123', 'test', 'root', 'user', 'demo', 'sample', 'guest',
            '1234', '12345', '123456789', 'password1', 'password!', 'Pass@123', 'Admin123',
            'Welcome1', 'admin@123', 'root123', 'test123', 'qwerty123', 'abc@123',
            'letmein123', 'password1!', 'P@ssw0rd', 'P@ssword', 'Passw0rd!', 'Admin@123',
            'secret', 'pass', 'changeme', 'Password', 'PASSWORD', 'Password1', 'Password!',
            'Jordan23', 'Iloveyou', 'Starwars', 'princess', 'soccer', 'ninja', 'mustang'
        ];

        const dictionaryWords = [
            'hello', 'world', 'computer', 'internet', 'security', 'hacker', 'system',
            'network', 'server', 'database', 'program', 'software', 'hardware', 'digital',
            'crypto', 'cipher', 'encode', 'decode', 'algorithm', 'function', 'variable',
            'constant', 'pointer', 'memory', 'storage', 'process', 'thread', 'kernel',
            'shell', 'terminal', 'command', 'execute', 'compile', 'debug', 'error',
            'access', 'account', 'backup', 'cloud', 'data', 'file', 'folder', 'email'
        ];

        // Hybrid password mutations
        function generateMutations(word) {
            const mutations = [word];
            mutations.push(word + '123');
            mutations.push(word + '!');
            mutations.push(word + '@123');
            mutations.push(word + '1');
            mutations.push(word + '2023');
            mutations.push(word + '2024');
            mutations.push(word.charAt(0).toUpperCase() + word.slice(1));
            mutations.push(word.toUpperCase());
            mutations.push(word + word);
            return mutations;
        }

        // Detect hash type
        function detectHashType(hash) {
            const length = hash.length;
            if (length === 32) return 'md5';
            if (length === 40) return hash.match(/^[a-f0-9]+$/i) ? 'sha1' : 'ripemd160';
            if (length === 56) return 'sha224';
            if (length === 64) return 'sha256';
            if (length === 96) return 'sha384';
            if (length === 128) return 'sha512';
            return null;
        }

        // Generate character set for brute force
        function getCharacterSet(type) {
            switch(type) {
                case 'numeric': return '0123456789';
                case 'lowercase': return 'abcdefghijklmnopqrstuvwxyz';
                case 'uppercase': return 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
                case 'alpha': return 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
                case 'all': return 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()';
                default: return 'abcdefghijklmnopqrstuvwxyz0123456789';
            }
        }

        // Brute force generator
        function* bruteForceGenerator(charset, maxLength) {
            for (let length = 1; length <= maxLength; length++) {
                yield* generateCombinations(charset, length);
            }
        }

        function* generateCombinations(charset, length, prefix = '') {
            if (length === 0) {
                yield prefix;
                return;
            }
            for (let char of charset) {
                yield* generateCombinations(charset, length - 1, prefix + char);
            }
        }

        // Start cracking process
        async function startCracking() {
            const hashInput = document.getElementById('hashInput').value.trim();
            if (!hashInput) {
                alert('Please enter at least one hash to crack!');
                return;
            }

            const hashes = hashInput.split('\n').map(h => h.trim()).filter(h => h);
            const hashType = document.getElementById('hashType').value;
            const attackMode = document.getElementById('attackMode').value;

            isRunning = true;
            attemptCount = 0;
            startTime = Date.now();
            
            document.getElementById('progressBar').classList.add('show');
            document.getElementById('resultsSection').classList.add('show');
            document.getElementById('resultsContainer').innerHTML = '';
            
            document.getElementById('totalHashes').textContent = hashes.length;
            document.getElementById('crackedCount').textContent = '0';
            document.getElementById('attemptsCount').textContent = '0';

            startTimer();

            let crackedCount = 0;
            for (let hash of hashes) {
                if (!isRunning) break;

                const detectedType = hashType === 'auto' ? detectHashType(hash) : hashType;
                if (!detectedType) {
                    addResult(hash, null, 'error', 'Unable to detect hash type');
                    continue;
                }

                let wordlist;
                let useRainbowTable = false;
                
                switch(attackMode) {
                    case 'rainbow':
                        useRainbowTable = true;
                        wordlist = [];
                        break;
                    case 'common':
                        wordlist = commonPasswords;
                        break;
                    case 'dictionary':
                        wordlist = [...commonPasswords, ...dictionaryWords];
                        break;
                    case 'hybrid':
                        // Generate mutations of all dictionary words
                        const hybridList = [];
                        [...commonPasswords, ...dictionaryWords].forEach(word => {
                            hybridList.push(...generateMutations(word));
                        });
                        wordlist = [...new Set(hybridList)]; // Remove duplicates
                        break;
                    case 'custom':
                        const customInput = document.getElementById('customWordlist').value.trim();
                        wordlist = customInput ? customInput.split('\n').map(w => w.trim()) : commonPasswords;
                        break;
                    case 'bruteforce':
                        const charset = getCharacterSet(document.getElementById('charSet').value);
                        const maxLen = parseInt(document.getElementById('maxLength').value);
                        wordlist = bruteForceGenerator(charset, maxLen);
                        break;
                }

                // Try rainbow table first (instant lookup)
                if (useRainbowTable || attackMode === 'rainbow') {
                    const rainbowResult = rainbowTable[hash.toLowerCase()];
                    if (rainbowResult && (detectedType === rainbowResult.algo || hashType === 'auto')) {
                        crackedCount++;
                        addResult(hash, rainbowResult.password, 'success', 
                            `Algorithm: ${detectedType.toUpperCase()} - Rainbow Table (Instant)`);
                        document.getElementById('crackedCount').textContent = crackedCount;
                        document.getElementById('attemptsCount').textContent = '1';
                        continue;
                    } else if (attackMode === 'rainbow') {
                        addResult(hash, null, 'error', `Not found in rainbow table (${detectedType.toUpperCase()})`);
                        continue;
                    }
                }

                const result = await crackHash(hash, detectedType, wordlist);
                if (result) {
                    crackedCount++;
                    addResult(hash, result, 'success', `Algorithm: ${detectedType.toUpperCase()}`);
                } else {
                    addResult(hash, null, 'error', `Not found in wordlist (${detectedType.toUpperCase()})`);
                }

                document.getElementById('crackedCount').textContent = crackedCount;
            }

            stopCracking();
        }

        // Crack individual hash (optimized with Web Workers and batch processing)
        async function crackHash(targetHash, algorithm, wordlist) {
            const isGenerator = typeof wordlist[Symbol.iterator] === 'function' && 
                               wordlist.constructor.name === 'GeneratorFunction';
            
            // For generators (brute force), use single-threaded approach
            if (isGenerator || wordlist.next) {
                const batchSize = 100;
                let batch = [];
                
                for (let password of wordlist) {
                    if (!isRunning) return null;
                    batch.push(password);
                    
                    if (batch.length >= batchSize) {
                        for (let pwd of batch) {
                            attemptCount++;
                            const hashedPassword = await hashString(pwd, algorithm);
                            if (hashedPassword === targetHash.toLowerCase()) {
                                return pwd;
                            }
                        }
                        
                        document.getElementById('attemptsCount').textContent = attemptCount.toLocaleString();
                        await new Promise(resolve => setTimeout(resolve, 0));
                        batch = [];
                    }

                    if (attemptCount > 100000) {
                        return null;
                    }
                }
                
                // Process remaining batch
                for (let pwd of batch) {
                    attemptCount++;
                    const hashedPassword = await hashString(pwd, algorithm);
                    if (hashedPassword === targetHash.toLowerCase()) {
                        return pwd;
                    }
                }
                
                return null;
            } else {
                // For array wordlists, use parallel workers for maximum speed
                const result = await crackHashParallel(targetHash, algorithm, wordlist);
                document.getElementById('attemptsCount').textContent = attemptCount.toLocaleString();
                return result;
            }
        }

        function updateProgress(percent) {
            const fill = document.getElementById('progressFill');
            fill.style.width = percent + '%';
            fill.textContent = Math.round(percent) + '%';
        }

        function addResult(hash, password, type, message) {
            const container = document.getElementById('resultsContainer');
            const resultCard = document.createElement('div');
            resultCard.className = `result-card ${type}`;
            
            let statusText = type === 'success' ? 'CRACKED' : 'FAILED';
            resultCard.innerHTML = `
                <h3>${statusText}</h3>
                <div class="hash-display"><strong>Hash:</strong> ${hash}</div>
                ${password ? `<div class="hash-display"><strong>Password:</strong> ${password}</div>` : ''}
                <p><em>${message}</em></p>
            `;
            
            container.appendChild(resultCard);
        }

        function startTimer() {
            let lastAttempts = 0;
            timerInterval = setInterval(() => {
                const elapsed = Math.floor((Date.now() - startTime) / 1000);
                document.getElementById('timeElapsed').textContent = elapsed + 's';
                
                // Calculate hash rate (hashes per second)
                const currentAttempts = attemptCount;
                const hashRate = currentAttempts - lastAttempts;
                lastAttempts = currentAttempts;
                
                document.getElementById('hashRate').textContent = hashRate.toLocaleString();
                document.getElementById('workerStatus').textContent = workers.length;
            }, 1000);
        }

        function stopCracking() {
            isRunning = false;
            terminateWorkers();
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            updateProgress(100);
            document.getElementById('workerStatus').textContent = '0';
        }

        async function generateHash() {
            const text = prompt('Enter text to hash:');
            if (!text) return;

            const algorithm = document.getElementById('hashType').value === 'auto' ? 'md5' : document.getElementById('hashType').value;
            const hash = await hashString(text, algorithm);

            const container = document.getElementById('resultsContainer');
            document.getElementById('resultsSection').classList.add('show');
            
            const resultCard = document.createElement('div');
            resultCard.className = 'result-card';
            resultCard.innerHTML = `
                <h3>GENERATED HASH</h3>
                <div class="hash-display"><strong>Text:</strong> ${text}</div>
                <div class="hash-display"><strong>Algorithm:</strong> ${algorithm.toUpperCase()}</div>
                <div class="hash-display"><strong>Hash:</strong> ${hash}</div>
            `;
            
            container.insertBefore(resultCard, container.firstChild);
        }
    </script>
</body>
</html>
